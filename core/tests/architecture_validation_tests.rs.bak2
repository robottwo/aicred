//! Architecture validation tests for the new scanner architecture.
//! 
//! These tests verify that the refactored scanner architecture correctly:
//! - Populates provider_instances from discovered keys
//! - Maintains accurate provider and model counts
//! - Prevents duplicate entries
//! - Correctly maps settings (temperature, base_url, etc.)
//! - Handles edge cases (missing keys, invalid configs, mixed providers)

use genai_keyfinder_core::models::{ConfigInstance, DiscoveredKey};
use genai_keyfinder_core::scanner::Scanner;
use genai_keyfinder_core::scanners::{ClaudeDesktopScanner, GshScanner, RooCodeScanner, ScannerPlugin};
use std::path::Path;

#[test]
fn test_gsh_scanner_architecture() {
    let scanner = GshScanner;
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_gsh_config.gshrc");
    
    // Read the test configuration
    let content = std::fs::read_to_string(&config_path)
        .expect("Failed to read test GSH config");
    
    // Parse the configuration
    let result = scanner.parse_config(&config_path, &content)
        .expect("Failed to parse GSH config");
    
    println!("\n=== GSH Scanner Architecture Test ===");
    println!("Discovered keys: {}", result.keys.len());
    println!("Config instances: {}", result.instances.len());
    
    // Verify keys were discovered
    assert!(!result.keys.is_empty(), "Should discover API keys");
    
    // Verify config instance was created
    assert_eq!(result.instances.len(), 1, "Should create exactly one config instance");
    
    let config_instance = &result.instances[0];
    println!("Provider instances: {}", config_instance.provider_instances.len());
    
    // Verify provider_instances are populated
    assert!(!config_instance.provider_instances.is_empty(), 
        "Config instance should have provider instances");
    
    // Get all provider instances
    let provider_instances = config_instance.provider_instances.all_instances();
    println!("Total provider instances: {}", provider_instances.len());
    
    // Verify each provider instance
    for (i, instance) in provider_instances.iter().enumerate() {
        println!("\nProvider Instance {}:", i + 1);
        println!("  Type: {}", instance.provider_type);
        println!("  Display Name: {}", instance.display_name);
        println!("  Key Count: {}", instance.key_count());
        println!("  Has Valid Keys: {}", instance.has_valid_keys());
        println!("  Models: {:?}", instance.models);
        
        // Verify basic properties
        assert!(!instance.provider_type.is_empty(), "Provider type should not be empty");
        assert!(!instance.display_name.is_empty(), "Display name should not be empty");
    }
    
    // Verify no duplicate provider instances and collect provider types
    let mut provider_types = std::collections::HashSet::new();
    let mut provider_type_list = Vec::new();
    for instance in provider_instances {
        provider_type_list.push(instance.provider_type.as_str());
        assert!(provider_types.insert(&instance.provider_type),
            "Found duplicate provider instance: {}", instance.provider_type);
    }
    
    println!("\nProvider types found: {:?}", provider_type_list);
    
    // Should have groq, openrouter, openai, anthropic, google, huggingface
    assert!(provider_type_list.contains(&"groq"), "Should have groq provider");
    assert!(provider_type_list.contains(&"openrouter"), "Should have openrouter provider");
    assert!(provider_type_list.contains(&"openai"), "Should have openai provider");
    assert!(provider_type_list.contains(&"anthropic"), "Should have anthropic provider");
    
    println!("\n✓ GSH Scanner architecture validation passed");
}

#[test]
fn test_claude_desktop_scanner_architecture() {
    let scanner = ClaudeDesktopScanner;
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_claude_desktop_config.json");
    
    // Read the test configuration
    let content = std::fs::read_to_string(config_path)
        .expect("Failed to read test Claude Desktop config");
    
    // Parse the configuration
    let result = scanner.parse_config(&config_path, &content)
        .expect("Failed to parse Claude Desktop config");
    
    println!("\n=== Claude Desktop Scanner Architecture Test ===");
    println!("Discovered keys: {}", result.keys.len());
    println!("Config instances: {}", result.instances.len());
    
    // Verify keys were discovered
    assert_eq!(result.keys.len(), 1, "Should discover exactly one API key");
    assert_eq!(result.keys[0].provider, "anthropic", "Key should be for anthropic provider");
    
    // Verify config instance was created
    assert_eq!(result.instances.len(), 1, "Should create exactly one config instance");
    
    let config_instance = &result.instances[0];
    println!("Provider instances: {}", config_instance.provider_instances.len());
    
    // Verify provider_instances are populated
    assert_eq!(config_instance.provider_instances.len(), 1, 
        "Should have exactly one provider instance");
    
    // Get the provider instance
    let provider_instances = config_instance.provider_instances.all_instances();
    assert_eq!(provider_instances.len(), 1, "Should have one provider instance");
    
    let provider_instance = provider_instances[0];
    println!("\nProvider Instance:");
    println!("  Type: {}", provider_instance.provider_type);
    println!("  Display Name: {}", provider_instance.display_name);
    println!("  Key Count: {}", provider_instance.key_count());
    println!("  Has Valid Keys: {}", provider_instance.has_valid_keys());
    
    // Verify provider instance properties
    assert_eq!(provider_instance.provider_type, "anthropic", "Should be anthropic provider");
    assert_eq!(provider_instance.key_count(), 1, "Should have one key");
    assert!(provider_instance.has_valid_keys(), "Should have valid keys");
    
    // Verify metadata is preserved
    assert!(config_instance.metadata.contains_key("model"), "Should have model metadata");
    assert!(config_instance.metadata.contains_key("temperature"), "Should have temperature metadata");
    assert!(config_instance.metadata.contains_key("max_tokens"), "Should have max_tokens metadata");
    
    println!("\nMetadata:");
    for (key, value) in &config_instance.metadata {
        println!("  {}: {}", key, value);
    }
    
    println!("\n✓ Claude Desktop Scanner architecture validation passed");
}

#[test]
fn test_roo_code_scanner_architecture() {
    let scanner = RooCodeScanner;
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_roo_code_config.json");
    
    // Read the test configuration
    let content = std::fs::read_to_string(config_path)
        .expect("Failed to read test Roo Code config");
    
    // Parse the configuration
    let result = scanner.parse_config(config_path, &content)
        .expect("Failed to parse Roo Code config");
    
    println!("\n=== Roo Code Scanner Architecture Test ===");
    println!("Discovered keys: {}", result.keys.len());
    println!("Config instances: {}", result.instances.len());
    
    // Verify keys were discovered
    assert!(!result.keys.is_empty(), "Should discover API keys");
    
    // Verify config instance was created
    assert_eq!(result.instances.len(), 1, "Should create exactly one config instance");
    
    let config_instance = &result.instances[0];
    println!("Provider instances: {}", config_instance.provider_instances.len());
    
    // Verify provider_instances are populated
    assert!(!config_instance.provider_instances.is_empty(), 
        "Config instance should have provider instances");
    
    // Get all provider instances
    let provider_instances = config_instance.provider_instances.all_instances();
    println!("Total provider instances: {}", provider_instances.len());
    
    // Verify each provider instance
    for (i, instance) in provider_instances.iter().enumerate() {
        println!("\nProvider Instance {}:", i + 1);
        println!("  Type: {}", instance.provider_type);
        println!("  Display Name: {}", instance.display_name);
        println!("  Key Count: {}", instance.key_count());
        println!("  Has Valid Keys: {}", instance.has_valid_keys());
        
        // Verify basic properties
        assert!(!instance.provider_type.is_empty(), "Provider type should not be empty");
        assert!(!instance.display_name.is_empty(), "Display name should not be empty");
    }
    
    // Verify no duplicate provider instances
    let mut provider_types = std::collections::HashSet::new();
    for instance in provider_instances {
        assert!(provider_types.insert(&instance.provider_type), 
            "Found duplicate provider instance: {}", instance.provider_type);
    }
    
    println!("\n✓ Roo Code Scanner architecture validation passed");
}

#[test]
fn test_gsh_missing_keys_edge_case() {
    let scanner = GshScanner;
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_gsh_missing_keys.gshrc");
    
    // Read the test configuration
    let content = std::fs::read_to_string(config_path)
        .expect("Failed to read test GSH config with missing keys");
    
    // Parse the configuration
    let result = scanner.parse_config(config_path, &content)
        .expect("Failed to parse GSH config with missing keys");
    
    println!("\n=== GSH Missing Keys Edge Case Test ===");
    println!("Discovered keys: {}", result.keys.len());
    println!("Config instances: {}", result.instances.len());
    
    // Should still create a config instance even with missing keys
    assert_eq!(result.instances.len(), 1, "Should create config instance even with missing keys");
    
    let config_instance = &result.instances[0];
    println!("Provider instances: {}", config_instance.provider_instances.len());
    
    // May have some provider instances from non-empty keys
    let provider_instances = config_instance.provider_instances.all_instances();
    println!("Total provider instances: {}", provider_instances.len());
    
    // Verify that invalid/empty keys are not included
    for instance in provider_instances {
        println!("\nProvider Instance:");
        println!("  Type: {}", instance.provider_type);
        println!("  Key Count: {}", instance.key_count());
        
        // All included instances should have at least one key
        assert!(instance.key_count() > 0, "Provider instance should have at least one key");
    }
    
    println!("\n✓ GSH missing keys edge case validation passed");
}

#[test]
fn test_invalid_config_edge_case() {
    let scanner = ClaudeDesktopScanner;
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_invalid_config.json");
    
    // Read the test configuration
    let content = std::fs::read_to_string(&config_path)
        .expect("Failed to read invalid config");
    
    // Parse the configuration
    let result = scanner.parse_config(&config_path, &content)
        .expect("Failed to parse invalid config");
    
    println!("\n=== Invalid Config Edge Case Test ===");
    println!("Discovered keys: {}", result.keys.len());
    println!("Config instances: {}", result.instances.len());
    
    // Should not discover any keys
    assert_eq!(result.keys.len(), 0, "Should not discover keys in invalid config");
    
    // Should still create a config instance
    assert_eq!(result.instances.len(), 1, "Should create config instance even for invalid config");
    
    let config_instance = &result.instances[0];
    println!("Provider instances: {}", config_instance.provider_instances.len());
    
    // Should not have any provider instances (no valid keys)
    assert_eq!(config_instance.provider_instances.len(), 0, 
        "Should not have provider instances without valid keys");
    
    println!("\n✓ Invalid config edge case validation passed");
}

#[test]
fn test_no_duplicate_keys_across_scanners() {
    println!("\n=== No Duplicate Keys Test ===");
    
    // Test GSH scanner
    let gsh_scanner = GshScanner;
    let gsh_config_path = Path::new(manifest_dir).join("tests/fixtures/test_gsh_config.gshrc");
    let gsh_content = std::fs::read_to_string(gsh_config_path)
        .expect("Failed to read GSH config");
    let gsh_result = gsh_scanner.parse_config(&gsh_config_path, &gsh_content)
        .expect("Failed to parse GSH config");
    
    // Collect all key hashes
    let mut all_hashes = std::collections::HashSet::new();
    let mut duplicate_count = 0;
    
    for key in &gsh_result.keys {
        if !all_hashes.insert(&key.hash) {
            duplicate_count += 1;
            println!("Duplicate key found: provider={}, hash={}", key.provider, key.hash);
        }
    }
    
    println!("GSH Scanner:");
    println!("  Total keys: {}", gsh_result.keys.len());
    println!("  Unique keys: {}", all_hashes.len());
    println!("  Duplicates: {}", duplicate_count);
    
    assert_eq!(duplicate_count, 0, "GSH scanner should not produce duplicate keys");
    
    println!("\n✓ No duplicate keys validation passed");
}

#[test]
fn test_provider_instance_counts() {
    println!("\n=== Provider Instance Counts Test ===");
    
    // Test GSH scanner
    let gsh_scanner = GshScanner;
    let gsh_config_path = Path::new(manifest_dir).join("tests/fixtures/test_gsh_config.gshrc");
    let gsh_content = std::fs::read_to_string(gsh_config_path)
        .expect("Failed to read GSH config");
    let gsh_result = gsh_scanner.parse_config(gsh_config_path, &gsh_content)
        .expect("Failed to parse GSH config");
    
    let config_instance = &gsh_result.instances[0];
    let provider_instances = config_instance.provider_instances.all_instances();
    
    println!("GSH Config:");
    println!("  Total discovered keys: {}", gsh_result.keys.len());
    println!("  Total provider instances: {}", provider_instances.len());
    
    // Count keys per provider
    let mut provider_key_counts = std::collections::HashMap::new();
    for key in &gsh_result.keys {
        *provider_key_counts.entry(&key.provider).or_insert(0) += 1;
    }
    
    println!("\nKeys per provider:");
    for (provider, count) in &provider_key_counts {
        println!("  {}: {}", provider, count);
    }
    
    println!("\nProvider instances:");
    for instance in provider_instances {
        println!("  {}: {} keys", instance.provider_type, instance.key_count());
        
        // Verify key count matches
        let expected_count = provider_key_counts.get(&instance.provider_type)
            .copied()
            .unwrap_or(0);
        assert_eq!(instance.key_count(), expected_count, 
            "Provider instance key count should match discovered keys for {}", 
            instance.provider_type);
    }
    
    println!("\n✓ Provider instance counts validation passed");
}

#[test]
fn test_settings_mapping() {
    println!("\n=== Settings Mapping Test ===");
    
    // Test Claude Desktop scanner with metadata
    let scanner = ClaudeDesktopScanner;
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let config_path = Path::new(manifest_dir).join("tests/fixtures/test_claude_desktop_config.json");
    let content = std::fs::read_to_string(&config_path)
        .expect("Failed to read Claude Desktop config");
    let result = scanner.parse_config(&config_path, &content)
        .expect("Failed to parse Claude Desktop config");
    
    let config_instance = &result.instances[0];
    
    println!("Claude Desktop Config Metadata:");
    for (key, value) in &config_instance.metadata {
        println!("  {}: {}", key, value);
    }
    
    // Verify specific settings are mapped
    assert_eq!(config_instance.metadata.get("model"), Some(&"claude-3-opus-20240229".to_string()),
        "Model should be correctly mapped");
    assert_eq!(config_instance.metadata.get("temperature"), Some(&"0.7".to_string()),
        "Temperature should be correctly mapped");
    assert_eq!(config_instance.metadata.get("max_tokens"), Some(&"4096".to_string()),
        "Max tokens should be correctly mapped");
    
    println!("\n✓ Settings mapping validation passed");
}